var documenterSearchIndex = {"docs":
[{"location":"#FusionSyntheticDiagnostics.jl","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Installation","page":"FusionSyntheticDiagnostics.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"First install Julia, then:","category":"page"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"using Pkg\nPkg.add(\"FusionSyntheticDiagnostics\")","category":"page"},{"location":"#Synthetic-Diagnostics","page":"FusionSyntheticDiagnostics.jl","title":"Synthetic Diagnostics","text":"","category":"section"},{"location":"#Interferometer","page":"FusionSyntheticDiagnostics.jl","title":"Interferometer","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"Synthetic interferometer can be added using IMAS compatible JSON file that describes the metadata and the line of sight of chords. On computation, the interferometer uses edge profiles and core profiles data in the IMAS IDS to numerically integrate electron density along the line of sight and returns data in IMAS IDS interferometer object.","category":"page"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"add_interferometer!\ncompute_interferometer!","category":"page"},{"location":"#FusionSyntheticDiagnostics.add_interferometer!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.add_interferometer!","text":"add_interferometer!(\n    config::String=default_ifo,\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite::Bool=false, verbose::Bool=false, rtol::Float64=1e-3, n_e_gsi::Int=5,\n)::IMAS.dd\n\nAdd interferometer to IMAS structure using a JSON file and compute the line integrated electron density if not present\n\n\n\n\n\nadd_interferometer!(\n    config::Dict{Symbol, Any},\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite::Bool=false, verbose::Bool=false, rtol::Float64=1e-3, n_e_gsi::Int=5,\n)::IMAS.dd\n\nAdd interferometer to IMAS structure using a Dict and compute the line integrated electron density if not present\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.compute_interferometer!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.compute_interferometer!","text":"compute_interferometer!(\n    @nospecialize(ids::IMAS.dd);\n    rtol::Float64=1e-3,\n    n_e_gsi::Int=5,\n)\n\nComputed the line integrated electron density from the interferometer data present in IDS structure for all the chords. The computation is based on the edge profile data and core profile data present in the IDS structure.\n\n\n\n\n\n","category":"function"},{"location":"#Langmuir-Probes","page":"FusionSyntheticDiagnostics.jl","title":"Langmuir Probes","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"Langmuir probes can be added using IMAS compatible JSON file that describes the metadata and positions of embedded or reciprocating probes. Computation is currently supported for embedded langmuir probes only which uses the edge profiles data to report the edge electron and average ion temperature and electron density. If plasma potential and probe biasing information is available, it will use a langmuir probe current model to also calculate the ion saturaton current and current density as reported by a typical probe in IMAS data format.","category":"page"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"add_langmuir_probes!\ncompute_langmuir_probes!\nlangmuir_probe_current","category":"page"},{"location":"#FusionSyntheticDiagnostics.add_langmuir_probes!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.add_langmuir_probes!","text":"add_langmuir_probes!(\n    config::String=default_lp,\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite=false, verbose=false, kwargs...,\n)::IMAS.dd\n\nAdd langmuir probes positions and other parameters from JSON file to ids structure\n\n\n\n\n\nadd_langmuir_probes!(\n    config::Dict{Symbol, Any},\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite=false, verbose=false, kwargs...,\n)::IMAS.dd\n\nAdd langmuir probes positions and other parameters from Dictionary to ids structure\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.compute_langmuir_probes!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.compute_langmuir_probes!","text":"compute_langmuir_probes!(\n    ids::IMAS.dd;\n    v_plasma::Union{Float64, Vector{Float64}, Nothing}=nothing,\n    v_floating::Union{Float64, Vector{Float64}, Nothing}=nothing,\n    v_probe::Union{Float64, Vector{Float64}, Nothing}=nothing,\n    v_plasma_noise::Union{Noise, Nothing}=nothing,\n    Z_eff::Float64=1.0,\n    m_i_amu::Float64=2.014, # Deuterium\n    probe_type::Symbol=:cylindrical,\n    ne_noise::Union{Noise, Nothing}=nothing,\n    te_noise::Union{Noise, Nothing}=nothing,\n    ti_noise::Union{Noise, Nothing}=nothing,\n    n_e_gsi::Int=5,\n)\n\nCompute langmuir probe outputs for all the embedded langmuir probes in the ids structure using edge profiles data. If v_plasma or v_floating are provided along with v_probe, then langmuir_probe_current() is used to compute the ion saturation current and parallel current density and stored in the IDS. Noise models can be added for electron density and temperature and ion average temperature as power spectral densities using data type Noise.\n\nInput arguments:\n\nids: IMAS.dd object\nv_plasma: Plasma potential (in V) or a vector of plasma potentials for each time step\nv_floating: Floating potential (in V) or a vector of floating potentials for each time step\nv_probe: Probe potential (in V) or a vector of probe potentials for each time step\nv_plasma_noise: Noise object for plasma potential\nZ_eff: Effective charge of the ion\nm_i_amu: Ion mass in atomic mass units (amu)\nprobe_type: Type of the probe, either :cylindrical or :spherical\nne_noise: Noise object for electron density\nte_noise: Noise object for electron temperature\nti_noise: Noise object for average ion temperature\nn_e_gsi: Grid subset index that is used in edge profiles data for electron density, electron temperature, and average ion temperature.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.langmuir_probe_current","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.langmuir_probe_current","text":"langmuir_probe_current(\n    Δv::Float64,\n    Te::Float64,\n    Ti=::Float64,\n    ne::Float64,\n    A::Float64,\n    m_i_amu=2.04,\n    Z_eff::Float64=1.0;\n    probe_type::Symbol=:cylindrical,\n)::Float64\n\nLangmuir Probe current model for cylindrical and spherical probes.\n\nFor Δv <= 0:\n\nI_probe = -I_isc (1 - fracΔvT_i)^ex - I_esc e^fracΔvT_e\n\nFor Δv > 0:\n\nI_probe = -I_esc (1 + fracΔvT_e)^ex - I_isc e^-fracΔvT_i\n\nwhere\n\nI_isc = frac12 A q_i n_e sqrte (T_e + T_i)  m_i\n\nI_esc = -frac14 A e n_e sqrt8 e T_e  m_e\n\nwhere A is the effective surface area of the probe, q_i(Z_effe) is the total charge of the ion, and ex is 1 for spherical and 0.5 for cylindrical probes.\n\nInput arguments:\n\nΔv: Bias voltage (v_probe - v_plasma)\nTe: Electron temperature (in eV)\nTi: Ion temperature (in eV)\nne: Electron density (in m^-3)\nA: Effective surface area of the probe (in m^2)\nm_i_amu: Ion mass in atomic mass units (amu)\nZ_eff: Effective charge of the ion (in units of elementary charge e)\nprobe_type: Type of the probe, either :cylindrical or :spherical\n\nRef: L. Conde, \"An introduction to Langmuir probe diagnostics of plasmas\" (2011)\n\n\n\n\n\n","category":"function"},{"location":"#Synthetic-Actuators","page":"FusionSyntheticDiagnostics.jl","title":"Synthetic Actuators","text":"","category":"section"},{"location":"#Gas-Injection","page":"FusionSyntheticDiagnostics.jl","title":"Gas Injection","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"Gas valves can be added using IMAS compatible JSON file that describes the metadata, response curve, and positions of gas valves. If ids.gas_injection.valve[:].voltage.data is present, the gas output flow rate is calculated. Additionally, if a valve model dictionary is passed, more realistic actuation can be modeled that includes second order low pass effect, latency, and dribble effect.","category":"page"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"add_gas_injection!\ncompute_gas_injection\ncompute_gas_injection!\nFusionSyntheticDiagnostics.get_lpf\nFusionSyntheticDiagnostics.dribble\nFusionSyntheticDiagnostics.downsample_smooth\nFusionSyntheticDiagnostics.find_delay\nget_gas_injection_response\nFusionSyntheticDiagnostics.gi_model\nFusionSyntheticDiagnostics.int_gi_model\nget_required_gas_cmd","category":"page"},{"location":"#FusionSyntheticDiagnostics.add_gas_injection!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.add_gas_injection!","text":"add_gas_injection!(\n    config::String=default_gas_injection,\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite::Bool=false,\n    verbose::Bool=false,\n)::IMAS.dd\n\nAdd gas valves from a JSON file and compute the gas flow rate based on the command signal in the gas valves.\n\n\n\n\n\nadd_gas_injection!(\n    config::Dict{Symbol, Any},\n    @nospecialize(ids::IMAS.dd)=IMAS.dd();\n    overwrite::Bool=false,\n    verbose::Bool=false,\n)::IMAS.dd\n\nAdd gas valves from a dictionary and compute the gas flow rate based on the command signal in the gas valves.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.compute_gas_injection","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.compute_gas_injection","text":"compute_gas_injection(\n    tt::Vector{Float64},\n    cmd_voltage::Vector{Float64},\n    response_curve_voltage::Vector{Float64},\n    response_curve_flow_rate::Vector{Float64};\n    valve_model::Dict{Symbol, Any}=Dict{Symbol, Any}(),\n    global_latency::Float64=0.0,\n)::Tuple{Vector{Float64}, Vector{Float64}, Union{Nothing, Vector{Float64}}}\n\nLowest level function to compute gas flow rate based on the command voltage data and response cruve data all provided in base Julia types.\n\n\n\n\n\ncompute_gas_injection(\n    tt::Vector{Float64},\n    cmd_voltage::Vector{Float64},\n    response_curve::IMAS.gas_injection__valve___response_curve;\n    valve_model::Dict{Symbol, Any}=Dict{Symbol, Any}(),\n    global_latency::Float64=0.0,\n)::Tuple{Vector{Float64}, Vector{Float64}, Union{Nothing, Vector{Float64}}}\n\nConvinience function format where response curve is provided as the ids type but everything else is provided in base Julia types.\n\n\n\n\n\ncompute_gas_injection(\n    valve::IMAS.gas_injection__valve;\n    valve_model::Dict{Symbol, Any}=Dict{Symbol, Any}(),\n    global_latency::Float64=0.0,\n)::Tuple{Vector{Float64}, Vector{Float64}, Union{Nothing, Vector{Float64}}}\n\nTop most level function to compute gas flow rate for a single valve.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.compute_gas_injection!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.compute_gas_injection!","text":"compute_gas_injection!(\n    ids::IMAS.dd;\n    valves::Dict{String, Dict{Symbol, Any}}=Dict{String, Dict{Symbol, Any}}(),\n)::Array{Vector{Float64}}\n\nCompute the gas flow rate based on the command signal in the all gas valves.\n\n\n\n\n\ncompute_gas_injection!(\n    valve::IMAS.gas_injection__valve;\n    valve_model::Dict{Symbol, Any}=Dict{Symbol, Any}(),\n    global_latency::Float64=0.0,\n)::Union{Nothing, Vector{Float64}}\n\nIn-place version of compute_gas_injection function for a single valve.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.get_lpf","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.get_lpf","text":"get_lpf(\n    fs::Float64,\n    tau::Float64,\n    damping::Float64,\n    gain::Float64,\n)::SecondOrderSections\n\nCreate a second order filter with the given parameters. The filter is created in the s-domain and then converted to the z-domain using bilinear transform. In s-domain, the filter transfer function is:\n\nH(s) = k fracωₙ^2 s^2 + 2 gamma ωₙ s + ωₙ^2\n\nwhere ωₙ = 2π / tau, gamma is damping and k is gain.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.dribble","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.dribble","text":"dribble(\n    data::Vector{Float64},\n    decay_time_constant::Float64,\n    fs::Float64,\n)::Vector{Float64}\n\nFunction to model dribble effect when gas command falls too sharply due to remaining gas in the pipe. The function compares change in data(ΔD) at every time step with\n\nΔD  -frac1τ f_s e^ - left( frac1τ f_s right) \n\nwhere τ(decay_time_constant) is the decay time constant and f_s(f_s) is the sampling frequency. If the above condition is found true, the function forces data to decay exponentially with the decay time constant untill the condition is false. The function returns the modified data.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.downsample_smooth","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.downsample_smooth","text":"downsample_smooth(\n    tt::Vector{Float64},\n    data::Vector{Float64},\n    dt_res::Float64;\n    default_start=0.0,\n)::Vector{Float64}\n\nDownsample and smooth the data to a new time resolution. The time axis does not need to be equally spaced in time. The function creates a new time axis with spacing given by dt_res and then averages the data points that fall within the new time bin. If no data points fall within the new time bin, the function uses the last data point to fill the new time bin. default_start is used to fill first time bin if no data is present in the first time bin.\n\n\n\n\n\ndownsample_smooth(\n    tt::Vector{Float64},\n    data::Vector{Float64},\n    tt_res::Vector{Float64};\n    default_start=0.0,\n)::Vector{Float64}\n\nDownsample and smooth the data to a new time resolution. The time axis does not need to be equally spaced in time. The function uses tt_res as the new resampled time axis and averages the data points that fall within the new time bin. If no data points fall within the new time bin, the function uses the last data point to fill the new time bin. default_start is used to fill first time bin if no data is present in the first time bin. Note that tt_res need not be equally spaced in time either.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.find_delay","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.find_delay","text":"find_delay(\n    data1::Vector{Float64},\n    data2::Vector{Float64},\n    dt::Float64,\n)::Float64\n\nFind the delay between two signals using cross-correlation. The function returns the delay in seconds. The function assumes that data1 is the reference signal and data2 is the signal that is delayed with respect to data1. The funciton assumes that data1 and data2 are sampled at the same rate and are of same length. dt is the time resolution of the data.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.get_gas_injection_response","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.get_gas_injection_response","text":"get_gas_injection_response(\n    cmd::Vector{Float64},\n    cmd_tt::Vector{Float64},\n    P_ves::Vector{Float64},\n    P_ves_tt::Vector{Float64},\n    V_ves::Float64;\n    resample_dt::Float64=0.02,\n    gi_fit_guess::Vector{Float64}=[1.0, 1.0],\n    response_curve_voltage::Vector{Float64}=collect(0:0.001:11),\n)::Tuple{IMAS.gas_injection__valve___response_curve, Dict{Symbol, Any}}\n\nFunction to fit a gas calibration shot data to a gas injection model. It requires 2 set of data:\n\ncmd, and cmd_tt are the command sent in Volts and the corresponding time axis.\nP_ves and P_ves_tt are the pressure in the vessel and the corresponding time axis.\n\nV_ves is the volume of the vessel. The function returns a tuple of response_curve object and a valve model dictionary that can be used in compute_gas_injection! or compute_gas_injection functions.\n\nOptional keyword arguments:\n\nresample_dt: Time resolution to resample the data.\ngi_fit_guess: Initial guess for the gas injection model parameters.\nresponse_curve_voltage: Voltage axis for storing the response curve.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.gi_model","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.gi_model","text":"gi_model(x::Vector{Float64}, p::Vector{Float64})::Vector{Float64}\n\nNon linear gas injection model. The model is given by:\n\nGamma = p_1 (sqrtx^2 p_2^2 + 1 - 1)\n\nwhere x is the input voltage in Volts and Gamma is the flow rate in Pa m³/ s\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.int_gi_model","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.int_gi_model","text":"int_gi_model(x::Vector{Float64}, p::Vector{Float64})::Vector{Float64}\n\nCumulative sum of gas injection model. This function models the accumulated gas in the vessel volume. Note that this is a numerical cumulative sum and does not change the units of output. Returned output is in Pa m³/ s.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.get_required_gas_cmd","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.get_required_gas_cmd","text":"get_required_gas_cmd(\n        required_flow_rate::Float64,\n        response_curve::IMAS.gas_injection__valve___response_curve,\n    )::Float64\n\nFunction to get the required gas command voltage to achieve the required flow rate.\n\n\n\n\n\nget_required_gas_cmd(\n    required_flow_rate::Vector{Float64},\n    response_curve::IMAS.gas_injection__valve___response_curve,\n)::Vector{Float64}\n\nFunction to get the required gas command voltage to achieve the required flow rate.\n\n\n\n\n\n","category":"function"},{"location":"#Noise-model","page":"FusionSyntheticDiagnostics.jl","title":"Noise model","text":"","category":"section"},{"location":"","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.jl","text":"Noise\ngenerate_noise\ngenerate_noise!","category":"page"},{"location":"#FusionSyntheticDiagnostics.Noise","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.Noise","text":"Noise\n\nA structure to represent a noise model. It holds power spectral density of noise and/or the time series of noise. The power spectral density is stored as a DSP.Periodograms.Periodogram object.\n\nConstructors:\n\nNoise(time::Vector{Float64}, signal::Vector{Float64}, binwidth::Float64)\n\nCreate a noise model from a time series of noise. The power spectral density is calculated and stored for regenaeration of noise in future.\n\nNoise(pgram::DSP.Periodograms.Periodogram)\n\nCreate a noise model from a power spectral density data given as a DSP.Periodograms.Periodogram object.\n\nNoise(power_spectrum::Vector{Float64}, freq::AbstractRange)\n\nCreate a noise model from a power spectral density data given as a vector along with frequency values. The power spectral density is stored as a DSP.Periodograms.Periodogram calculated from the input data.\n\n\n\n\n\n","category":"type"},{"location":"#FusionSyntheticDiagnostics.generate_noise","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.generate_noise","text":"generate_noise(n::Noise, t::Vector{Float64})::Vector{Float64}\n\nGenerate a noise signal based on the power spectral density stored in the noise model that corresponds to the time axis t. The noise signal is generated by summing up the cosine waves with uniformly distributed random phase and amplitude based on the power spectral density.\n\n\n\n\n\n","category":"function"},{"location":"#FusionSyntheticDiagnostics.generate_noise!","page":"FusionSyntheticDiagnostics.jl","title":"FusionSyntheticDiagnostics.generate_noise!","text":"generate_noise!(n::Noise, t::Vector{Float64})::Noise\n\nIn-place version of generate_noise().\n\n\n\n\n\n","category":"function"}]
}
